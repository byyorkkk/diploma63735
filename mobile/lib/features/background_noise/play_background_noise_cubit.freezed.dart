// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'play_background_noise_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PlayBackgroundNoiseState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            BackgroundNoise backgroundNoise, PlayerData playerData)
        loaded,
    required TResult Function() error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(BackgroundNoise backgroundNoise, PlayerData playerData)?
        loaded,
    TResult? Function()? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(BackgroundNoise backgroundNoise, PlayerData playerData)?
        loaded,
    TResult Function()? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayBackgroundNoiseInitial value) initial,
    required TResult Function(PlayBackgroundNoiseLoading value) loading,
    required TResult Function(PlayBackgroundNoiseLoaded value) loaded,
    required TResult Function(PlayBackgroundNoiseError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlayBackgroundNoiseInitial value)? initial,
    TResult? Function(PlayBackgroundNoiseLoading value)? loading,
    TResult? Function(PlayBackgroundNoiseLoaded value)? loaded,
    TResult? Function(PlayBackgroundNoiseError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayBackgroundNoiseInitial value)? initial,
    TResult Function(PlayBackgroundNoiseLoading value)? loading,
    TResult Function(PlayBackgroundNoiseLoaded value)? loaded,
    TResult Function(PlayBackgroundNoiseError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlayBackgroundNoiseStateCopyWith<$Res> {
  factory $PlayBackgroundNoiseStateCopyWith(PlayBackgroundNoiseState value,
          $Res Function(PlayBackgroundNoiseState) then) =
      _$PlayBackgroundNoiseStateCopyWithImpl<$Res, PlayBackgroundNoiseState>;
}

/// @nodoc
class _$PlayBackgroundNoiseStateCopyWithImpl<$Res,
        $Val extends PlayBackgroundNoiseState>
    implements $PlayBackgroundNoiseStateCopyWith<$Res> {
  _$PlayBackgroundNoiseStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PlayBackgroundNoiseInitialCopyWith<$Res> {
  factory _$$PlayBackgroundNoiseInitialCopyWith(
          _$PlayBackgroundNoiseInitial value,
          $Res Function(_$PlayBackgroundNoiseInitial) then) =
      __$$PlayBackgroundNoiseInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PlayBackgroundNoiseInitialCopyWithImpl<$Res>
    extends _$PlayBackgroundNoiseStateCopyWithImpl<$Res,
        _$PlayBackgroundNoiseInitial>
    implements _$$PlayBackgroundNoiseInitialCopyWith<$Res> {
  __$$PlayBackgroundNoiseInitialCopyWithImpl(
      _$PlayBackgroundNoiseInitial _value,
      $Res Function(_$PlayBackgroundNoiseInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PlayBackgroundNoiseInitial implements PlayBackgroundNoiseInitial {
  const _$PlayBackgroundNoiseInitial();

  @override
  String toString() {
    return 'PlayBackgroundNoiseState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlayBackgroundNoiseInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            BackgroundNoise backgroundNoise, PlayerData playerData)
        loaded,
    required TResult Function() error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(BackgroundNoise backgroundNoise, PlayerData playerData)?
        loaded,
    TResult? Function()? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(BackgroundNoise backgroundNoise, PlayerData playerData)?
        loaded,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayBackgroundNoiseInitial value) initial,
    required TResult Function(PlayBackgroundNoiseLoading value) loading,
    required TResult Function(PlayBackgroundNoiseLoaded value) loaded,
    required TResult Function(PlayBackgroundNoiseError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlayBackgroundNoiseInitial value)? initial,
    TResult? Function(PlayBackgroundNoiseLoading value)? loading,
    TResult? Function(PlayBackgroundNoiseLoaded value)? loaded,
    TResult? Function(PlayBackgroundNoiseError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayBackgroundNoiseInitial value)? initial,
    TResult Function(PlayBackgroundNoiseLoading value)? loading,
    TResult Function(PlayBackgroundNoiseLoaded value)? loaded,
    TResult Function(PlayBackgroundNoiseError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class PlayBackgroundNoiseInitial implements PlayBackgroundNoiseState {
  const factory PlayBackgroundNoiseInitial() = _$PlayBackgroundNoiseInitial;
}

/// @nodoc
abstract class _$$PlayBackgroundNoiseLoadingCopyWith<$Res> {
  factory _$$PlayBackgroundNoiseLoadingCopyWith(
          _$PlayBackgroundNoiseLoading value,
          $Res Function(_$PlayBackgroundNoiseLoading) then) =
      __$$PlayBackgroundNoiseLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PlayBackgroundNoiseLoadingCopyWithImpl<$Res>
    extends _$PlayBackgroundNoiseStateCopyWithImpl<$Res,
        _$PlayBackgroundNoiseLoading>
    implements _$$PlayBackgroundNoiseLoadingCopyWith<$Res> {
  __$$PlayBackgroundNoiseLoadingCopyWithImpl(
      _$PlayBackgroundNoiseLoading _value,
      $Res Function(_$PlayBackgroundNoiseLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PlayBackgroundNoiseLoading implements PlayBackgroundNoiseLoading {
  const _$PlayBackgroundNoiseLoading();

  @override
  String toString() {
    return 'PlayBackgroundNoiseState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlayBackgroundNoiseLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            BackgroundNoise backgroundNoise, PlayerData playerData)
        loaded,
    required TResult Function() error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(BackgroundNoise backgroundNoise, PlayerData playerData)?
        loaded,
    TResult? Function()? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(BackgroundNoise backgroundNoise, PlayerData playerData)?
        loaded,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayBackgroundNoiseInitial value) initial,
    required TResult Function(PlayBackgroundNoiseLoading value) loading,
    required TResult Function(PlayBackgroundNoiseLoaded value) loaded,
    required TResult Function(PlayBackgroundNoiseError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlayBackgroundNoiseInitial value)? initial,
    TResult? Function(PlayBackgroundNoiseLoading value)? loading,
    TResult? Function(PlayBackgroundNoiseLoaded value)? loaded,
    TResult? Function(PlayBackgroundNoiseError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayBackgroundNoiseInitial value)? initial,
    TResult Function(PlayBackgroundNoiseLoading value)? loading,
    TResult Function(PlayBackgroundNoiseLoaded value)? loaded,
    TResult Function(PlayBackgroundNoiseError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class PlayBackgroundNoiseLoading implements PlayBackgroundNoiseState {
  const factory PlayBackgroundNoiseLoading() = _$PlayBackgroundNoiseLoading;
}

/// @nodoc
abstract class _$$PlayBackgroundNoiseLoadedCopyWith<$Res> {
  factory _$$PlayBackgroundNoiseLoadedCopyWith(
          _$PlayBackgroundNoiseLoaded value,
          $Res Function(_$PlayBackgroundNoiseLoaded) then) =
      __$$PlayBackgroundNoiseLoadedCopyWithImpl<$Res>;
  @useResult
  $Res call({BackgroundNoise backgroundNoise, PlayerData playerData});

  $PlayerDataCopyWith<$Res> get playerData;
}

/// @nodoc
class __$$PlayBackgroundNoiseLoadedCopyWithImpl<$Res>
    extends _$PlayBackgroundNoiseStateCopyWithImpl<$Res,
        _$PlayBackgroundNoiseLoaded>
    implements _$$PlayBackgroundNoiseLoadedCopyWith<$Res> {
  __$$PlayBackgroundNoiseLoadedCopyWithImpl(_$PlayBackgroundNoiseLoaded _value,
      $Res Function(_$PlayBackgroundNoiseLoaded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? backgroundNoise = null,
    Object? playerData = null,
  }) {
    return _then(_$PlayBackgroundNoiseLoaded(
      backgroundNoise: null == backgroundNoise
          ? _value.backgroundNoise
          : backgroundNoise // ignore: cast_nullable_to_non_nullable
              as BackgroundNoise,
      playerData: null == playerData
          ? _value.playerData
          : playerData // ignore: cast_nullable_to_non_nullable
              as PlayerData,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PlayerDataCopyWith<$Res> get playerData {
    return $PlayerDataCopyWith<$Res>(_value.playerData, (value) {
      return _then(_value.copyWith(playerData: value));
    });
  }
}

/// @nodoc

class _$PlayBackgroundNoiseLoaded implements PlayBackgroundNoiseLoaded {
  const _$PlayBackgroundNoiseLoaded(
      {required this.backgroundNoise, required this.playerData});

  @override
  final BackgroundNoise backgroundNoise;
  @override
  final PlayerData playerData;

  @override
  String toString() {
    return 'PlayBackgroundNoiseState.loaded(backgroundNoise: $backgroundNoise, playerData: $playerData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlayBackgroundNoiseLoaded &&
            (identical(other.backgroundNoise, backgroundNoise) ||
                other.backgroundNoise == backgroundNoise) &&
            (identical(other.playerData, playerData) ||
                other.playerData == playerData));
  }

  @override
  int get hashCode => Object.hash(runtimeType, backgroundNoise, playerData);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PlayBackgroundNoiseLoadedCopyWith<_$PlayBackgroundNoiseLoaded>
      get copyWith => __$$PlayBackgroundNoiseLoadedCopyWithImpl<
          _$PlayBackgroundNoiseLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            BackgroundNoise backgroundNoise, PlayerData playerData)
        loaded,
    required TResult Function() error,
  }) {
    return loaded(backgroundNoise, playerData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(BackgroundNoise backgroundNoise, PlayerData playerData)?
        loaded,
    TResult? Function()? error,
  }) {
    return loaded?.call(backgroundNoise, playerData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(BackgroundNoise backgroundNoise, PlayerData playerData)?
        loaded,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(backgroundNoise, playerData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayBackgroundNoiseInitial value) initial,
    required TResult Function(PlayBackgroundNoiseLoading value) loading,
    required TResult Function(PlayBackgroundNoiseLoaded value) loaded,
    required TResult Function(PlayBackgroundNoiseError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlayBackgroundNoiseInitial value)? initial,
    TResult? Function(PlayBackgroundNoiseLoading value)? loading,
    TResult? Function(PlayBackgroundNoiseLoaded value)? loaded,
    TResult? Function(PlayBackgroundNoiseError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayBackgroundNoiseInitial value)? initial,
    TResult Function(PlayBackgroundNoiseLoading value)? loading,
    TResult Function(PlayBackgroundNoiseLoaded value)? loaded,
    TResult Function(PlayBackgroundNoiseError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class PlayBackgroundNoiseLoaded implements PlayBackgroundNoiseState {
  const factory PlayBackgroundNoiseLoaded(
      {required final BackgroundNoise backgroundNoise,
      required final PlayerData playerData}) = _$PlayBackgroundNoiseLoaded;

  BackgroundNoise get backgroundNoise;
  PlayerData get playerData;
  @JsonKey(ignore: true)
  _$$PlayBackgroundNoiseLoadedCopyWith<_$PlayBackgroundNoiseLoaded>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlayBackgroundNoiseErrorCopyWith<$Res> {
  factory _$$PlayBackgroundNoiseErrorCopyWith(_$PlayBackgroundNoiseError value,
          $Res Function(_$PlayBackgroundNoiseError) then) =
      __$$PlayBackgroundNoiseErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PlayBackgroundNoiseErrorCopyWithImpl<$Res>
    extends _$PlayBackgroundNoiseStateCopyWithImpl<$Res,
        _$PlayBackgroundNoiseError>
    implements _$$PlayBackgroundNoiseErrorCopyWith<$Res> {
  __$$PlayBackgroundNoiseErrorCopyWithImpl(_$PlayBackgroundNoiseError _value,
      $Res Function(_$PlayBackgroundNoiseError) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PlayBackgroundNoiseError implements PlayBackgroundNoiseError {
  const _$PlayBackgroundNoiseError();

  @override
  String toString() {
    return 'PlayBackgroundNoiseState.error()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlayBackgroundNoiseError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            BackgroundNoise backgroundNoise, PlayerData playerData)
        loaded,
    required TResult Function() error,
  }) {
    return error();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(BackgroundNoise backgroundNoise, PlayerData playerData)?
        loaded,
    TResult? Function()? error,
  }) {
    return error?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(BackgroundNoise backgroundNoise, PlayerData playerData)?
        loaded,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PlayBackgroundNoiseInitial value) initial,
    required TResult Function(PlayBackgroundNoiseLoading value) loading,
    required TResult Function(PlayBackgroundNoiseLoaded value) loaded,
    required TResult Function(PlayBackgroundNoiseError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PlayBackgroundNoiseInitial value)? initial,
    TResult? Function(PlayBackgroundNoiseLoading value)? loading,
    TResult? Function(PlayBackgroundNoiseLoaded value)? loaded,
    TResult? Function(PlayBackgroundNoiseError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PlayBackgroundNoiseInitial value)? initial,
    TResult Function(PlayBackgroundNoiseLoading value)? loading,
    TResult Function(PlayBackgroundNoiseLoaded value)? loaded,
    TResult Function(PlayBackgroundNoiseError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PlayBackgroundNoiseError implements PlayBackgroundNoiseState {
  const factory PlayBackgroundNoiseError() = _$PlayBackgroundNoiseError;
}
